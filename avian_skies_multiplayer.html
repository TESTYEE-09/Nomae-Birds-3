<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avian Skies: Multiplayer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        
        /* UI Layer */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Leaderboard */
        #leaderboard { 
            position: absolute; top: 20px; right: 20px; 
            background: rgba(0,0,0,0.6); color: white; padding: 10px; border-radius: 5px;
            min-width: 200px; font-size: 14px;
        }
        #leaderboard h3 { margin: 0 0 5px 0; border-bottom: 1px solid #aaa; padding-bottom: 5px; text-align: center; color: #87CEEB; }
        .lb-entry { display: flex; justify-content: space-between; margin-bottom: 2px; }
        .lb-name { font-weight: bold; }
        .lb-score { color: gold; }
        
        /* HUD */
        #hud { position: absolute; bottom: 20px; left: 20px; color: white; text-shadow: 2px 2px 0 #000; display: none; }
        .stat-bar { width: 200px; height: 15px; background: rgba(0,0,0,0.5); margin-bottom: 5px; border: 1px solid white; position: relative; }
        .stat-fill { height: 100%; width: 100%; transition: width 0.1s; }
        #health-fill { background-color: #ff4444; }
        #speed-fill { background-color: #44ff44; }
        #boost-fill { background-color: #44aaff; }
        
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 50%; transform: translate(-50%, -50%); display: none; }
        #message-area { position: absolute; top: 30%; width: 100%; text-align: center; color: white; font-size: 20px; font-weight: bold; text-shadow: 1px 1px 4px black; opacity: 0; transition: opacity 0.5s; }
        
        /* Main Menu Overlay */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; pointer-events: auto; z-index: 10;
        }
        h1 { font-size: 4em; margin: 0 0 10px 0; color: #87CEEB; text-shadow: 0 0 10px #fff; }
        .subtitle { color: #aaa; margin-bottom: 30px; font-style: italic; }
        
        /* Menu Form */
        .menu-group { margin-bottom: 20px; text-align: center; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #87CEEB; }
        input[type="text"] { 
            padding: 10px; font-size: 18px; border-radius: 5px; border: none; text-align: center; width: 250px;
            background: #333; color: white; border: 1px solid #555;
        }
        
        /* Bird Selection */
        .bird-select { display: flex; gap: 15px; justify-content: center; margin-top: 10px; }
        .bird-card { 
            background: #333; padding: 15px; border-radius: 8px; cursor: pointer; border: 2px solid transparent; width: 100px;
            transition: all 0.2s;
        }
        .bird-card:hover { transform: translateY(-5px); background: #444; }
        .bird-card.selected { border-color: #87CEEB; background: #222; box-shadow: 0 0 15px #87CEEB; }
        .bird-icon { width: 40px; height: 40px; border-radius: 50%; margin: 0 auto 10px auto; }
        .bird-name { font-weight: bold; display: block; margin-bottom: 5px; }
        .bird-stat { font-size: 11px; color: #ccc; display: block; }
        
        /* Buttons */
        .btn {
            background: #87CEEB; border: none; padding: 15px 50px; font-size: 22px; 
            margin-top: 30px; cursor: pointer; border-radius: 5px; font-weight: bold; color: #004d6e;
            transition: transform 0.2s; box-shadow: 0 4px 0 #00334a;
        }
        .btn:hover { transform: scale(1.05); background: #fff; }
        .btn:active { transform: scale(0.95); box-shadow: 0 2px 0 #00334a; }
        .btn:disabled { background: #555; color: #888; cursor: not-allowed; box-shadow: none; }

        .instructions { margin-top: 30px; text-align: left; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; font-size: 14px; }
        kbd { background: #333; border: 1px solid #777; border-radius: 4px; padding: 1px 5px; font-family: monospace; }
        #loading { color: #87CEEB; margin-bottom: 10px; }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="crosshair"></div>
        
        <div id="leaderboard">
            <h3>LEADERBOARD</h3>
            <div id="lb-content">
                <!-- Entries injected here -->
            </div>
        </div>

        <div id="message-area">PRESS [E] TO LOOT</div>
        
        <div id="hud">
            <div>HEALTH</div>
            <div class="stat-bar"><div id="health-fill" class="stat-fill"></div></div>
            <div>SPEED</div>
            <div class="stat-bar"><div id="speed-fill" class="stat-fill"></div></div>
            <div>STAMINA</div>
            <div class="stat-bar"><div id="boost-fill" class="stat-fill"></div></div>
        </div>
    </div>

    <div id="overlay">
        <h1>AVIAN SKIES</h1>
        <div class="subtitle">Multiplayer Aerial Combat</div>
        
        <div id="menu-content">
            <div class="menu-group">
                <label>PILOT NAME</label>
                <input type="text" id="player-name" placeholder="Enter Name" maxlength="10" value="Guest">
            </div>

            <div class="menu-group">
                <label>SELECT CLASS</label>
                <div class="bird-select">
                    <div class="bird-card selected" onclick="selectBird('balanced', this)">
                        <div class="bird-icon" style="background: #1E90FF;"></div>
                        <span class="bird-name">SWIFT</span>
                        <span class="bird-stat">Spd: Mid</span>
                        <span class="bird-stat">HP: Mid</span>
                    </div>
                    <div class="bird-card" onclick="selectBird('speeder', this)">
                        <div class="bird-icon" style="background: #FF4500;"></div>
                        <span class="bird-name">RACER</span>
                        <span class="bird-stat">Spd: High</span>
                        <span class="bird-stat">HP: Low</span>
                    </div>
                    <div class="bird-card" onclick="selectBird('tank', this)">
                        <div class="bird-icon" style="background: #228B22;"></div>
                        <span class="bird-name">TANK</span>
                        <span class="bird-stat">Spd: Low</span>
                        <span class="bird-stat">HP: High</span>
                    </div>
                </div>
            </div>

            <div id="loading">Connecting to servers...</div>
            <button class="btn" id="start-btn" disabled>TAKE FLIGHT</button>
        </div>

        <div class="instructions">
            <p><kbd>MOUSE</kbd> Steer &nbsp; <kbd>W</kbd>/<kbd>S</kbd> Speed &nbsp; <kbd>SPACE</kbd> Dash</p>
            <p><kbd>E</kbd> Loot Nest (Slow down near nest)</p>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <!-- Firebase -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // NOTE: deleteDoc is imported here for cleanup on page close
        import { getFirestore, collection, doc, setDoc, onSnapshot, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- BIRD STATS CONFIG ---
        const BIRD_TYPES = {
            balanced: { color: 0x1E90FF, maxSpeed: 80, health: 100, turnSpeed: 1.5, name: "Swift" },
            speeder:  { color: 0xFF4500, maxSpeed: 110, health: 60, turnSpeed: 2.0, name: "Racer" },
            tank:     { color: 0x228B22, maxSpeed: 60, health: 180, turnSpeed: 1.0, name: "Tank" }
        };

        // --- GLOBAL GAME CONFIG ---
        const CONFIG = {
            worldSize: 2000,
            treeCount: 200,
            nestChance: 0.35,
            enemyCount: 0, // Pure PvP for now
            minSpeed: 10,
            syncRate: 100
        };

        // --- FIREBASE ---
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let app, auth, db, user;
        let onlinePlayers = {};
        let playerRef = null;

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, clock;
        let player, world;
        let particles = [];
        let isPlaying = false;
        let keys = { w: false, s: false, space: false, e: false };
        let mouse = { x: 0, y: 0 };
        let lastSyncTime = 0;
        let localNests = [];
        let simplex; // Global noise instance
        
        // Setup State
        window.selectedBirdType = 'balanced';
        window.selectBird = function(type, el) {
            window.selectedBirdType = type;
            document.querySelectorAll('.bird-card').forEach(c => c.classList.remove('selected'));
            el.classList.add('selected');
        };

        // --- TERRAIN HELPER ---
        // This ensures trees and ground match perfectly
        function getTerrainHeight(x, z) {
            // Must match the logic used in ground generation
            return simplex.noise2D(x * 0.002, z * 0.002) * 50 + simplex.noise2D(x*0.01, z*0.01)*10;
        }

        // --- CLASSES ---

        class Bird {
            constructor(typeKey, isPlayer = false) {
                this.isPlayer = isPlayer;
                const stats = BIRD_TYPES[typeKey] || BIRD_TYPES['balanced'];
                
                this.stats = stats;
                this.speed = CONFIG.minSpeed;
                this.health = stats.health;
                this.maxHealth = stats.health;
                
                this.mesh = new THREE.Group();
                this.createMesh(stats.color);
                scene.add(this.mesh);

                this.velocity = new THREE.Vector3();
                this.direction = new THREE.Vector3(0, 0, 1);
            }

            createMesh(color) {
                // Body
                const bodyGeo = new THREE.ConeGeometry(2, 8, 8);
                const bodyMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
                bodyGeo.rotateX(Math.PI / 2); 
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.castShadow = true;
                this.mesh.add(body);

                // Wings
                const wingGeo = new THREE.BoxGeometry(8, 0.2, 3);
                const wingMat = new THREE.MeshStandardMaterial({ color: color });
                wingGeo.translate(4, 0, 0); 
                
                this.leftWing = new THREE.Mesh(wingGeo, wingMat);
                this.rightWing = new THREE.Mesh(wingGeo, wingMat);
                this.rightWing.rotation.z = Math.PI; 
                this.rightWing.scale.x = -1;

                this.mesh.add(this.leftWing);
                this.mesh.add(this.rightWing);

                // Beak
                const beakGeo = new THREE.ConeGeometry(0.5, 2, 8);
                const beakMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                beakGeo.rotateX(Math.PI / 2);
                const beak = new THREE.Mesh(beakGeo, beakMat);
                beak.position.z = 4;
                this.mesh.add(beak);
            }

            animateWings(dt, speedRatio) {
                const flapSpeed = 10 + (speedRatio * 15);
                const angle = Math.sin(clock.getElapsedTime() * flapSpeed) * 0.4;
                this.leftWing.rotation.z = angle;
                this.rightWing.rotation.z = -angle; 
            }
        }

        class PlayerBird extends Bird {
            constructor(typeKey, playerName) {
                super(typeKey, true);
                this.playerName = playerName;
                this.score = 0;
                this.nestsLooted = 0;
                this.stamina = 100;
                
                this.mesh.position.set(0, 150, 0);
                
                this.cameraTarget = new THREE.Object3D();
                this.mesh.add(this.cameraTarget);
                this.cameraTarget.position.set(0, 10, -30);
            }

            update(dt) {
                // Input handling
                if (keys.w) this.speed += 50 * dt;
                if (keys.s) this.speed -= 40 * dt;
                
                let isBoosting = false;
                if (keys.space && this.stamina > 0) {
                    this.speed += 80 * dt;
                    this.stamina -= 40 * dt;
                    isBoosting = true;
                } else {
                    this.stamina = Math.min(this.stamina + 10 * dt, 100);
                }

                // Stats based speed limit
                const maxS = isBoosting ? this.stats.maxSpeed * 1.5 : this.stats.maxSpeed;
                this.speed = Math.max(CONFIG.minSpeed, Math.min(this.speed, maxS));

                // Turn
                const rotationSpeed = this.stats.turnSpeed * dt;
                this.mesh.rotateY(-mouse.x * rotationSpeed * 15); 
                this.mesh.rotateX(-mouse.y * rotationSpeed * 15); 
                
                // Bank
                const targetRoll = -mouse.x * 25; 
                this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, targetRoll, 4 * dt);
                this.mesh.rotation.z *= 0.98;

                mouse.x = 0; mouse.y = 0;

                // Move
                this.direction.set(0, 0, 1).applyQuaternion(this.mesh.quaternion);
                this.velocity.copy(this.direction).multiplyScalar(this.speed);
                this.mesh.position.add(this.velocity.clone().multiplyScalar(dt));

                // Ground Collision
                const terrainH = getTerrainHeight(this.mesh.position.x, this.mesh.position.z);
                if (this.mesh.position.y < terrainH + 5) {
                    this.mesh.position.y = terrainH + 5;
                    this.mesh.rotateX(-0.5);
                }

                this.handleLooting();
                
                // Visuals
                this.animateWings(dt, this.speed / this.stats.maxSpeed);
                this.updateCamera(dt);
                this.syncNetwork();
            }

            updateCamera(dt) {
                const targetPos = new THREE.Vector3();
                this.cameraTarget.getWorldPosition(targetPos);
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(this.mesh.position);
            }

            handleLooting() {
                let nearNest = false;
                localNests.forEach((nest) => {
                    if (!nest.visible) return;

                    const dist = this.mesh.position.distanceTo(nest.position);
                    if (dist < 25) {
                        nearNest = true;
                        if (this.speed < this.stats.maxSpeed * 0.6) {
                             showMessage("PRESS [E] TO LOOT");
                             if (keys.e) {
                                 this.lootNest(nest);
                             }
                        } else {
                            showMessage("TOO FAST TO LOOT!");
                        }
                    }
                });
                if (!nearNest) hideMessage();
            }

            async lootNest(nest) {
                if (!user) return;
                nest.visible = false;
                spawnParticles(nest.position, 0xFFD700, 20);
                this.score += 100;
                this.nestsLooted++;
                
                // Sync Loot
                try {
                    const nestRef = doc(db, 'artifacts', appId, 'public', 'data', 'nests', nest.userData.id);
                    await setDoc(nestRef, { looted: true }, { merge: true });
                } catch (e) { console.error(e); }
                
                // Force immediate player sync to update leaderboard score
                this.syncNetwork(true);
            }

            syncNetwork(force = false) {
                if (!user) return;
                const now = Date.now();
                if (force || now - lastSyncTime > CONFIG.syncRate) {
                    lastSyncTime = now;
                    if (!playerRef) playerRef = doc(db, 'artifacts', appId, 'public', 'data', 'players', user.uid);
                    
                    setDoc(playerRef, {
                        x: this.mesh.position.x,
                        y: this.mesh.position.y,
                        z: this.mesh.position.z,
                        qx: this.mesh.quaternion.x,
                        qy: this.mesh.quaternion.y,
                        qz: this.mesh.quaternion.z,
                        qw: this.mesh.quaternion.w,
                        speed: this.speed,
                        birdType: window.selectedBirdType,
                        name: this.playerName,
                        score: this.score,
                        lastSeen: now
                    }).catch(err => { /* Error handled silently to prevent logging storm */ });
                }
            }
        }

        class RemoteBird extends Bird {
            constructor(id, data) {
                super(data.birdType || 'balanced');
                this.id = id;
                this.name = data.name || "Unknown";
                this.score = data.score || 0;
                this.targetPos = new THREE.Vector3(data.x, data.y, data.z);
                this.targetQuat = new THREE.Quaternion(data.qx, data.qy, data.qz, data.qw);
            }

            updateData(data) {
                this.targetPos.set(data.x, data.y, data.z);
                this.targetQuat.set(data.qx, data.qy, data.qz, data.qw);
                this.speed = data.speed || 0;
                this.score = data.score || 0;
                this.name = data.name || "Unknown";
                
                // If they changed bird type mid-session (unlikely but possible), rebuild mesh
                // Ignored for simplicity
            }

            update(dt) {
                this.mesh.position.lerp(this.targetPos, 5 * dt);
                this.mesh.quaternion.slerp(this.targetQuat, 5 * dt);
                this.animateWings(dt, this.speed / this.stats.maxSpeed);
            }
        }

        // --- SETUP ---

        async function initApp() {
            // 1. Firebase Auth
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (u) => {
                    user = u;
                    if (user) {
                        document.getElementById('loading').innerText = "Ready to fly.";
                        document.getElementById('start-btn').disabled = false;
                        
                        // Set up cleanup ONLY after we have a UID to reference
                        window.addEventListener('beforeunload', cleanupOnDisconnect);
                    }
                });
            } catch (e) {
                console.error(e);
                document.getElementById('loading').innerText = "Offline Mode";
                document.getElementById('start-btn').disabled = false;
                document.getElementById('start-btn').innerText = "PLAY OFFLINE";
            }
            
            // 2. Button Listeners
            document.getElementById('start-btn').addEventListener('click', startGame);
        }

        // Cleanup: Ensures player document is deleted when browser tab is closed/refreshed
        function cleanupOnDisconnect() {
            if (playerRef) {
                // Delete the player's document from the database
                deleteDoc(playerRef).catch(e => console.log("Failed to clean up player document:", e));
            }
        }

        function startGame() {
            const nameInput = document.getElementById('player-name').value || "Guest";
            const birdType = window.selectedBirdType;

            document.body.requestPointerLock();
            
            // Pointer lock listener to toggle UI
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === document.body) {
                    isPlaying = true;
                    document.getElementById('overlay').style.display = 'none';
                    document.getElementById('hud').style.display = 'block';
                    document.getElementById('leaderboard').style.display = 'block';
                    document.getElementById('crosshair').style.display = 'block';
                } else {
                    isPlaying = false;
                    document.getElementById('overlay').style.display = 'flex';
                }
            });

            // Initialize World and Game Player if not already done
            if (!scene) {
                initThreeJS(birdType, nameInput);
                // CRITICAL FIX: Setup Firestore listeners only AFTER the Three.js scene is ready
                setupSnapshotListeners();
            }
        }

        function setupSnapshotListeners() {
            if (!user) return;

            // PLAYERS Listener (Leaderboard + Rendering)
            const playersRef = collection(db, 'artifacts', appId, 'public', 'data', 'players');
            onSnapshot(playersRef, (snapshot) => {
                const now = Date.now();
                const lbData = [];
                const activeIds = new Set(); // Track IDs seen in this snapshot

                // Add self to leaderboard data if playing
                if (player) {
                    lbData.push({ name: player.playerName, score: player.score, isMe: true });
                }

                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (doc.id === user.uid) return;
                    
                    // Filter out stale players (> 10 seconds old)
                    if (now - data.lastSeen > 10000) return; 

                    activeIds.add(doc.id);

                    // Update 3D World
                    if (!onlinePlayers[doc.id]) {
                        onlinePlayers[doc.id] = new RemoteBird(doc.id, data);
                    } else {
                        onlinePlayers[doc.id].updateData(data);
                    }
                    
                    // Add to Leaderboard
                    lbData.push({ name: data.name, score: data.score || 0, isMe: false });
                });

                // CLEANUP: Remove birds that are no longer active
                Object.keys(onlinePlayers).forEach(id => {
                    if (!activeIds.has(id)) {
                        scene.remove(onlinePlayers[id].mesh);
                        delete onlinePlayers[id];
                    }
                });

                updateLeaderboardUI(lbData);
            });

            // NESTS Listener
            const nestsRef = collection(db, 'artifacts', appId, 'public', 'data', 'nests');
            onSnapshot(nestsRef, (snapshot) => {
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const nest = localNests.find(n => n.userData.id === doc.id);
                    if (nest && data.looted) {
                        nest.visible = false;
                    }
                });
            });
        }

        function updateLeaderboardUI(data) {
            // Sort by score desc
            data.sort((a, b) => b.score - a.score);
            
            const container = document.getElementById('lb-content');
            container.innerHTML = '';
            
            data.slice(0, 8).forEach(entry => {
                const div = document.createElement('div');
                div.className = 'lb-entry';
                if (entry.isMe) div.style.color = '#87CEEB';
                
                div.innerHTML = `
                    <span class="lb-name">${entry.name}</span>
                    <span class="lb-score">${entry.score}</span>
                `;
                container.appendChild(div);
            });
        }

        // --- THREE.JS ---

        function initThreeJS(birdType, playerName) {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.0015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffee, 1.2);
            dirLight.position.set(500, 1000, 500);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.far = 2500;
            dirLight.shadow.camera.left = -1000;
            dirLight.shadow.camera.right = 1000;
            dirLight.shadow.camera.top = 1000;
            dirLight.shadow.camera.bottom = -1000;
            scene.add(dirLight);

            clock = new THREE.Clock();
            
            createWorld();
            player = new PlayerBird(birdType, playerName);

            // Inputs
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('keydown', (e) => onKey(e, true), false);
            document.addEventListener('keyup', (e) => onKey(e, false), false);

            animate();
        }

        // --- WORLD GENERATION ---

        function createWorld() {
            // Seeded Random Helper
            let seed = 12345;
            const seededRandom = () => {
                const x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            };

            // Init Noise
            simplex = new SimplexNoise();

            // Ground
            const groundGeo = new THREE.PlaneGeometry(CONFIG.worldSize * 2, CONFIG.worldSize * 2, 64, 64);
            const count = groundGeo.attributes.position.count;
            groundGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(count * 3), 3));
            
            const colors = groundGeo.attributes.color;
            const positions = groundGeo.attributes.position;

            for (let i = 0; i < count; i++) {
                const x = positions.getX(i);
                // The geometry is flat initially (Z=0), but after rotation, Geo Z becomes World Y
                const z_in_world = -positions.getY(i); 
                const height = getTerrainHeight(x, z_in_world);
                positions.setZ(i, Math.max(-20, height));

                // Color
                const noiseVal = simplex.noise2D(x * 0.005, z_in_world * 0.005);
                if (noiseVal > 0.5) colors.setXYZ(i, 0.1, 0.4, 0.1);
                else if (noiseVal > 0) colors.setXYZ(i, 0.2, 0.6, 0.2);
                else colors.setXYZ(i, 0.3, 0.7, 0.3);
            }
            
            groundGeo.computeVertexNormals();
            const groundMat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8, flatShading: true });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Trees
            const treeGeo = new THREE.CylinderGeometry(2, 5, 20, 6);
            const leavesGeo = new THREE.ConeGeometry(15, 30, 8);
            const treeMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, flatShading: true });
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x228B22, flatShading: true });

            for(let i=0; i<CONFIG.treeCount; i++) {
                const x = (seededRandom() - 0.5) * CONFIG.worldSize;
                const z = (seededRandom() - 0.5) * CONFIG.worldSize;
                
                // FIX: Get correct height from our shared function
                const groundY = getTerrainHeight(x, z);

                const treeGroup = new THREE.Group();
                treeGroup.position.set(x, groundY + 10, z); // +10 to sit on ground (trunk is 20 high, centered at 0)

                const trunk = new THREE.Mesh(treeGeo, treeMat);
                trunk.castShadow = true; trunk.receiveShadow = true;
                treeGroup.add(trunk);

                const leaves = new THREE.Mesh(leavesGeo, leavesMat);
                leaves.position.y = 20; leaves.castShadow = true;
                treeGroup.add(leaves);

                scene.add(treeGroup);

                // Nests
                if (seededRandom() < CONFIG.nestChance) {
                    createNest(x, groundY + 35, z, `nest_${i}`); // +35 is top of tree
                }
            }
        }

        function createNest(x, y, z, id) {
            const nestGroup = new THREE.Group();
            nestGroup.position.set(x, y, z);

            const nestGeo = new THREE.TorusGeometry(4, 1.5, 6, 10);
            const nestMat = new THREE.MeshStandardMaterial({ color: 0x5C4033, flatShading: true });
            nestGeo.rotateX(Math.PI / 2);
            const nest = new THREE.Mesh(nestGeo, nestMat);
            nestGroup.add(nest);

            const eggGeo = new THREE.SphereGeometry(1.5, 8, 8);
            const eggMat = new THREE.MeshStandardMaterial({ color: 0xFFFDD0 });
            
            for(let k=0; k<3; k++) {
                const egg = new THREE.Mesh(eggGeo, eggMat);
                egg.position.set(Math.random()*2-1, 0, Math.random()*2-1);
                nestGroup.add(egg);
            }

            nestGroup.userData = { id: id, looted: false };
            scene.add(nestGroup);
            localNests.push(nestGroup);
        }

        // --- HELPERS ---

        function spawnParticles(pos, color, count) {
            const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            for(let i=0; i<count; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.position.x += (Math.random() - 0.5) * 5;
                mesh.position.y += (Math.random() - 0.5) * 5;
                const vel = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(20);
                scene.add(mesh);
                particles.push({ mesh: mesh, vel: vel, life: 1.0 });
            }
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= dt;
                p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
                p.mesh.rotation.x += dt * 5;
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        let msgTimeout;
        function showMessage(text) {
            const el = document.getElementById('message-area');
            el.innerText = text;
            el.style.opacity = 1;
            clearTimeout(msgTimeout);
            msgTimeout = setTimeout(() => el.style.opacity = 0, 2000);
        }
        function hideMessage() { document.getElementById('message-area').style.opacity = 0; }

        function onKey(e, pressed) {
            const key = e.key.toLowerCase();
            if (key === 'w') keys.w = pressed;
            if (key === 's') keys.s = pressed;
            if (key === ' ') keys.space = pressed;
            if (key === 'e') keys.e = pressed;
        }

        function onMouseMove(e) {
            if (!isPlaying) return;
            mouse.x = (e.movementX || 0) * 0.002;
            mouse.y = (e.movementY || 0) * 0.002;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);

            if (isPlaying && player) {
                player.update(dt);
                Object.values(onlinePlayers).forEach(p => p.update(dt));
                updateParticles(dt);

                const hpPct = Math.max(0, (player.health / player.maxHealth) * 100) + '%';
                const stPct = Math.max(0, player.stamina) + '%';
                const spPct = Math.min(100, (player.speed / player.stats.maxSpeed) * 100) + '%';
                document.getElementById('health-fill').style.width = hpPct;
                document.getElementById('boost-fill').style.width = stPct;
                document.getElementById('speed-fill').style.width = spPct;
            }
            renderer.render(scene, camera);
        }

        // START
        initApp();

    </script>
</body>
</html>
